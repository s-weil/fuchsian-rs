use crate::{
    algebraic_extensions::{Numeric, NumericAddIdentity},
    group_action::{Action, SpecialLinear},
    moebius::MoebiusTransformation,
    NUMERIC_THRESHOLD,
};
use std::{
    fmt::{self, Debug, Display},
    ops::Div,
};

/// Boundary points of the hyperbolic (Poincare) upper half plane (within C).
/// SpecialLinear preserves the boundary (maps boundary points to the boundary).
#[derive(PartialEq, Eq, Clone)]
pub enum BoundaryPoint<T> {
    Infinity,
    Regular(T),
}

impl<T> Display for BoundaryPoint<T>
where
    T: Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BoundaryPoint::Infinity => write!(f, "∞"),
            BoundaryPoint::Regular(t) => write!(f, "{}", t),
        }
    }
}
impl<T> Debug for BoundaryPoint<T>
where
    T: Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BoundaryPoint::Infinity => write!(f, "∞"),
            BoundaryPoint::Regular(t) => write!(f, "δ({})", t),
        }
    }
}
impl<T> Copy for BoundaryPoint<T> where T: Copy {}

/// Implement Action for Moebius transformations on the boundary.
impl<T> Action<BoundaryPoint<T>> for MoebiusTransformation<T>
where
    T: Numeric + Div<Output = T> + NumericAddIdentity + Copy,
    MoebiusTransformation<T>: SpecialLinear<T>,
{
    fn map(&self, x: &BoundaryPoint<T>) -> BoundaryPoint<T> {
        match x {
            BoundaryPoint::Infinity => {
                // Note: a and c cannot be 0 at the same time for regular matrices
                if self.c.is_zero(Some(NUMERIC_THRESHOLD)) {
                    BoundaryPoint::Infinity
                } else {
                    BoundaryPoint::Regular(self.a / self.c)
                }
            }
            BoundaryPoint::Regular(t) => {
                let denom = self.c * *t + self.d;
                if denom.is_zero(Some(NUMERIC_THRESHOLD)) {
                    BoundaryPoint::Infinity
                } else {
                    BoundaryPoint::Regular((self.a * *t + self.b) / denom)
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::BoundaryPoint;
    use crate::{
        fuchsian_group::FuchsianGroup,
        group_action::{Action, Orbit},
        moebius::MoebiusTransformation,
    };

    #[test]
    fn test_action_horocyclic() {
        let h = MoebiusTransformation::<f64>::new(1.0, 10.0, 0.0, 1.0);

        let boundary_infty: BoundaryPoint<f64> = BoundaryPoint::Infinity;
        let boundary_regular = BoundaryPoint::Regular(0.0);

        assert_eq!(h.map(&boundary_infty), BoundaryPoint::Infinity);
        assert_eq!(h.map(&boundary_regular), BoundaryPoint::Regular(10.0));
    }

    #[test]
    fn test_action_hyperbolic() {
        let h = MoebiusTransformation::<f64>::new(5.0, 0.0, 0.0, 0.2);

        // fixed point 1
        let boundary_infty: BoundaryPoint<f64> = BoundaryPoint::Infinity;
        assert_eq!(h.map(&boundary_infty), BoundaryPoint::Infinity);

        // fixed point 2
        let boundary_regular = BoundaryPoint::Regular(0.0);
        assert_eq!(h.map(&boundary_regular), BoundaryPoint::Regular(0.0));

        // no fixed point
        let boundary_regular = BoundaryPoint::Regular(1.0);
        assert_eq!(h.map(&boundary_regular), BoundaryPoint::Regular(25.0));
        let boundary_regular = BoundaryPoint::Regular(-1.0);
        assert_eq!(h.map(&boundary_regular), BoundaryPoint::Regular(-25.0));
    }

    // TODO: incorrect?
    #[test]
    fn test_action_rotation() {
        // no fixed points
        // rotation by pi/2 = 90 [cos(.), -sin(.); sin(.), cos(.)]
        let h = MoebiusTransformation::<f64>::new(0.0, -1.0, 1.0, 0.0);

        let b = BoundaryPoint::Regular(0.0);
        assert_eq!(h.map(&b), BoundaryPoint::Infinity);

        let b = BoundaryPoint::Infinity;
        assert_eq!(h.map(&b), BoundaryPoint::Regular(0.0));

        let b = BoundaryPoint::Regular(1.0);
        assert_eq!(h.map(&b), BoundaryPoint::Regular(-1.0));

        let b = BoundaryPoint::Regular(-1.0);
        assert_eq!(h.map(&b), BoundaryPoint::Regular(1.0));
    }

    #[test]
    fn test_boundary_orbit_modular_group() {
        // see https://en.wikipedia.org/wiki/Modular_group
        // the modular group is generated by the transformations z -> z+1 and z -> -1/z,
        // corresponding to the Moebius transformations g = [ 1, 1; 0, 1 ] and h = [ 0, -1; 1, 0 ]
        let g = MoebiusTransformation::<f32>::new(1.0, 1.0, 0.0, 1.0);
        let h = MoebiusTransformation::<f32>::new(0.0, -1.0, 1.0, 0.0);

        let fuchsian_group = FuchsianGroup::create_from_valid(vec![g, h]);

        let regular_bp = BoundaryPoint::Regular(1.0);
        let orbit = Orbit::sample(&fuchsian_group, &regular_bp, 100, None);

        assert_eq!(orbit.points.len(), 100);
        for p in orbit.points {
            assert_ne!(p, BoundaryPoint::Infinity);
            // TODO: somehow test on ration and denominator size
        }

        let inf_bp = BoundaryPoint::Infinity;
        let orbit = Orbit::sample(&fuchsian_group, &inf_bp, 100, None);

        assert_eq!(orbit.points.len(), 100);
    }
}
